<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C++ Tips and Tricks | fadeWrites</title>
<meta name=keywords content="C++"><meta name=description content="In this post, I will share some tips and tricks that I have learned while working with C++. Most of these tips are on optimization and performance improvement. I hope you find them useful. This post is useful to go through every once in a while, especially when you&rsquo;re rusty with C++.
Dealing with std::vector Always use reserve when you know the size of the vector // Reserve space for 1000 elements."><meta name=author content="Me"><link rel=canonical href=http://localhost:1313/posts/cpp_tips/><script src=https://kit.fontawesome.com/768c1f9b93.js crossorigin=anonymous></script><link crossorigin=anonymous href=/assets/css/stylesheet.758afc56b6051378a7e8c4e0338af4deae5ba554701b3fd5a4f6cfe9540e1660.css integrity="sha256-dYr8VrYFE3in6MTgM4r03q5bpVRwGz/VpPbP6VQOFmA=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/cpp_tips/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css integrity=sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js integrity=sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js integrity=sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})})</script><meta property="og:title" content="C++ Tips and Tricks"><meta property="og:description" content="In this post, I will share some tips and tricks that I have learned while working with C++. Most of these tips are on optimization and performance improvement. I hope you find them useful. This post is useful to go through every once in a while, especially when you&rsquo;re rusty with C++.
Dealing with std::vector Always use reserve when you know the size of the vector // Reserve space for 1000 elements."><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/cpp_tips/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-06-24T12:18:32-07:00"><meta property="article:modified_time" content="2024-06-24T12:18:32-07:00"><meta property="og:site_name" content="fadeWrites"><meta name=twitter:card content="summary"><meta name=twitter:title content="C++ Tips and Tricks"><meta name=twitter:description content="In this post, I will share some tips and tricks that I have learned while working with C++. Most of these tips are on optimization and performance improvement. I hope you find them useful. This post is useful to go through every once in a while, especially when you&rsquo;re rusty with C++.
Dealing with std::vector Always use reserve when you know the size of the vector // Reserve space for 1000 elements."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"C++ Tips and Tricks","item":"http://localhost:1313/posts/cpp_tips/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++ Tips and Tricks","name":"C\u002b\u002b Tips and Tricks","description":"In this post, I will share some tips and tricks that I have learned while working with C++. Most of these tips are on optimization and performance improvement. I hope you find them useful. This post is useful to go through every once in a while, especially when you\u0026rsquo;re rusty with C++.\nDealing with std::vector Always use reserve when you know the size of the vector // Reserve space for 1000 elements.","keywords":["C++"],"articleBody":"In this post, I will share some tips and tricks that I have learned while working with C++. Most of these tips are on optimization and performance improvement. I hope you find them useful. This post is useful to go through every once in a while, especially when you’re rusty with C++.\nDealing with std::vector Always use reserve when you know the size of the vector // Reserve space for 1000 elements. // v[i] will be an empty object if v[i] has not been assigned a value. std::vector\u003cT\u003e v; v.reserve(1000); // Reserve space for 1000 elements. // v[i] will be assigned the default value. std::string default_value = \"default\"; std::vector\u003cstd::string\u003e v_strings(1000, default_value); This is due to the way std::vector works. When you push an element into a vector, it checks if the current capacity is enough. If not, it allocates a new memory block, copies the elements, and deallocates the old memory block. This can be very expensive if you are pushing a lot of elements into the vector. By using reserve, you can avoid this overhead. Note that the same can be achieved by specifying the size in the constructor: std::vector v(1000);.\nAs you can already tell from the example above, the biggest difference between reserve and calling the constructor to specify the vector size at construction is that reserve does not initialize the slots in the buffer with anything so you shouldn’t reference indexes where you haven’t already put something because they will be uninitialized. On the other hand, when you specify the size in the constructor, each slot is initialized with an empty object or the default value specified in the second argument of the constructor.\nPut pointers in std::vector instead of objects // modern C++ class Foo { // ... }; int main { // -------------------------------------------------------------------- // Vector creation and object insertion. std::vector\u003cstd::unique_ptr\u003cFoo\u003e\u003e v; v.push_back(std::make_unique\u003cFoo\u003e(/* constructor args */)); v.push_back(std::make_unique\u003cFoo\u003e(/* constructor args */)); // ... // -------------------------------------------------------------------- // Do something with the objects. // The objects will be automatically deleted when the vector goes out of scope. return 0; } // older C++ int main { // -------------------------------------------------------------------- // Vector creation and object insertion. std::vector\u003cFoo*\u003e v; v.push_back(new Foo(/* constructor args */)); v.push_back(new Foo(/* constructor args */)); // ... // -------------------------------------------------------------------- // Do something with the objects. // -------------------------------------------------------------------- // Typical pipeline to delete the objects when you're done. for (std::vector\u003cFoo*\u003e::iterator it = v.begin(); it != v.end(); ++it) { delete *it; } v.clear(); // Purge the contents so no one tries to delete them again. // -------------------------------------------------------------------- return 0; } Doing this will reduce copy overhead. This is because an std::vector or any other standard libary container do not actually stores the object itself. Instead, it stores a copy of the object. This means that each time you put something in a vector, you aren’t really “putting” it anywhere; you’re copying it somewhere else with its copy constructor or assignment operator (C++ Cookbook, Stephens et. al.). The same applies to retrieving a value from a vector: you are copying what is in the vector at that location to your local variable. So, if you have a large object, copying it can be expensive. By using pointers, you can avoid this overhead.\nThis is because storing pointers require less CPU cycles than storing objects. When you store a pointer in a vector, only the address of the object is stored. This is much faster than copying the object. Also, when you retrieve an object from a vector of pointers, you are just copying the address of the object, not the object itself. This is much faster than copying the object.\nIf you are using older versions of C++, just remember that if you add pointers to a standard library container, the container doesn’t delete them when it’s destroyed. Containers destroy only the objects they contain, i.e., the variable holding the addresses of the objects pointed to, but a container doesn’t know that what it’s storing is a pointer or an object, all it knows is that it’s some object of type T (C++ Cookbook, Stephens et. al.).\nUse std::list instead of std::vector when you need to insert elements arbitrarily. // ... other includes #include std::list\u003cint\u003e l = {1, 2, 3, 4, 5}; // Say we want to insert 10 between 2 and 3. auto it = std::next(l.begin(), 2); // it points to l[2]. l.insert(it, 10); // l = {1, 2, 10, 3, 4, 5} This is because inserting an element in the middle of a vector is expensive. When you insert an element in the middle of a vector, all the elements after the insertion point have to be moved to make space for the new element. This is due to the nature of std::vector: it stores item in a contiguous memory space. This is not the case with std::list. In a list, each element is stored in a separate node, and each node has a pointer to the next node. So, inserting an element in the middle of a list is just a matter of changing the pointers of the nodes.\nCopying a subset of elements in an std::vector // ... other includes #include std::vector\u003cint\u003e v = {1, 2, 3, 4, 5}; std::vector\u003cint\u003e v2; // assign(first, last) copies elements pointed to by first up // to but not including last, i.e.: [first, last). it = std::find(v.begin(), v.end(), 4); v2.assign(v.begin(), it) // v2 = {1, 2, 3} You can also use a copy constructor but this way is more common.\nTLDR: Functor A functor, a.k.a. a function object, is a class that defines/overrides the operator() method. This allows you to create objects that “look like” functions. Functors are useful when you want to pass a function to another function, or when you want to store a function in a variable.\nConceptually, it is similar to a Python class with the __call__ method defined. Both allow objects to be used as if they were functions.\nI include a minimum-working-example in C++ and Python below.\n#include class CallCounter { public: CallCounter() : count(0) {} void operator()() { count++; std::cout \u003c\u003c \"Called \" \u003c\u003c count \u003c\u003c \" times\" \u003c\u003c std::endl; } private: int count; }; int main() { CallCounter counter; counter(); counter(); counter(); return 0; } class CallCounter: def __init__(self): self.count = 0 def __call__(self): self.count += 1 print(f\"Called {self.count} times\") counter = CallCounter() counter() counter() counter() TLDR: Predicate It’s just a functor that returns a bool. The name “predicate” is derived from the fact that it does not maintain a state and only returns a boolean value, i.e.: it is pure in some sense (pure ➡ predicate). It is used to test a condition.\nBelow are different ways to define a predicate in C++.\nFunction Pointer Predicate #include #include #include bool is_even(int n) { return n % 2 == 0; } int main() { std::vector\u003cint\u003e numbers = {1, 2, 3, 4, 5, 6}; auto it = std::find_if(numbers.begin(), numbers.end(), is_even); if (it != numbers.end()) { std::cout \u003c\u003c \"First even number: \" \u003c\u003c *it \u003c\u003c std::endl; } return 0; } Functor Predicate #include #include #include class IsEven { public: bool operator()(int n) const { return n % 2 == 0; } }; int main() { std::vector\u003cint\u003e numbers = {1, 2, 3, 4, 5, 6}; auto it = std::find_if(numbers.begin(), numbers.end(), IsEven()); if (it != numbers.end()) { std::cout \u003c\u003c \"First even number: \" \u003c\u003c *it \u003c\u003c std::endl; } return 0; } Lambda Predicate #include #include #include int main() { std::vector\u003cint\u003e numbers = {1, 2, 3, 4, 5, 6}; auto it = std::find_if(numbers.begin(), numbers.end(), [](int n) { return n % 2 == 0; }); if (it != numbers.end()) { std::cout \u003c\u003c \"First even number: \" \u003c\u003c *it \u003c\u003c std::endl; } return 0; } Some terminologies:\nUnary predicate: A predicate that takes one argument (and returns a bool). Binary predicate: A predicate that takes two arguments (and returns a bool). What’s actually happening in std::find_if Let’s take look at the function pointer predicate example above. What’s actually happening when you pass is_even to std::find_if? When you pass the predicate is_even() to std::find_if, you’re actually passing the address of the function, which the algorithm can then call on elements of the container.\nA function pointer is a just variable that stores the address of a function that can be called through it. This allows functions to be passed as arguments to other functions.\nTo declare a function pointer, for example, you can simply do the following:\nint foo(int a, int b) { return a + b; } int (*foo_ptr)(int, int) = foo; // Now you can call foo through foo_ptr. int result = foo_ptr(1, 2); Now, let’s take a look at what actually happens in std::find_if. Before that, let’s take a look at the signature of std::find_if:\ntemplate\u003cclass ExecutionPolicy, class ForwardIt, class UnaryPred\u003e ForwardIt find_if(ExecutionPolicy\u0026\u0026 policy, ForwardIt first, ForwardIt last, UnaryPred p); For now, don’t worry about the ExecutionPolicy parameter. The important parameters are ForwardIt first, ForwardIt last, and UnaryPred p. ForwardIt is a type that satisfies the requirements of a forward iterator. UnaryPred is a type that satisfies the requirements of a unary predicate.\nWhen you pass is_even to std::find_if, you’re actually passing the address of the function is_even. The algorithm then calls is_even on each element of the container. Let’s take a look at what’s happening:\nfor ( ; first != last; ++first) { if (p(*first)) { return first; } } return last; Here p is called wth *first as argument. In our case, p is a function pointer to is_even, so UnaryPred is bool(*)(int). So, this translates to:\n// ... if (is_even(*first)) { return first; } // ... Should I preincrement (++it) or postincrement (it++) iterators? Preincrement doesn’t create a temporary value to return each time, so it’s more efficient and is the preferred approach. Postincrement (it++) has to create a temporary variable because it returns the value of it before the increment. However, it can’t increment the value after it has returned, so it has to make a copy of the current value, increment the current value, then return the temporary value. Creating these temporary variables adds up after a while, so if you don’t require postincrement behavior, use preincrement (C++ Cookbook, Stephens et. al.).\n","wordCount":"1702","inLanguage":"en","datePublished":"2024-06-24T12:18:32-07:00","dateModified":"2024-06-24T12:18:32-07:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/cpp_tips/"},"publisher":{"@type":"Organization","name":"fadeWrites","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="fadeWrites (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>fadeWrites</a><div class=logo-switches></div></div><ul id=menu><li><a href=http://localhost:1313/tags/ title=tags><span>tags</span></a></li><li><a href=https://fadli0029.github.io/fadeStash/ title=about><span>about</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">C++ Tips and Tricks</h1><div class=post-meta><span title='2024-06-24 12:18:32 -0700 PDT'>June 24, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1702 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/fadli0029/fadeWrites/edit/main/content/posts/cpp_tips.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#dealing-with-stdvector>Dealing with <code>std::vector</code></a><ul><li><a href=#always-use-reserve-when-you-know-the-size-of-the-vector>Always use <code>reserve</code> when you know the size of the vector</a></li><li><a href=#put-pointers-in-stdvector-instead-of-objects>Put pointers in <code>std::vector</code> instead of objects</a></li><li><a href=#use-stdlist-instead-of-stdvector-when-you-need-to-insert-elements-arbitrarily>Use <code>std::list</code> instead of <code>std::vector</code> when you need to insert elements arbitrarily.</a></li><li><a href=#copying-a-subset-of-elements-in-an-stdvector>Copying a subset of elements in an <code>std::vector</code></a></li></ul></li><li><a href=#tldr-functor>TLDR: Functor</a></li><li><a href=#tldr-predicate>TLDR: Predicate</a></li><li><a href=#whats-actually-happening-in-stdfind_if>What&rsquo;s actually happening in <code>std::find_if</code></a></li><li><a href=#should-i-preincrement-it-or-postincrement-it-iterators>Should I preincrement (<code>++it</code>) or postincrement (<code>it++</code>) iterators?</a></li></ul></nav></div></details></div><div class=post-content><p>In this post, I will share some tips and tricks that I have learned while working with C++. Most of these tips are on optimization and performance improvement. I hope you find them useful. This post is useful to go through every once in a while, especially when you&rsquo;re rusty with C++.</p><h2 id=dealing-with-stdvector>Dealing with <code>std::vector</code><a hidden class=anchor aria-hidden=true href=#dealing-with-stdvector>#</a></h2><h3 id=always-use-reserve-when-you-know-the-size-of-the-vector>Always use <code>reserve</code> when you know the size of the vector<a hidden class=anchor aria-hidden=true href=#always-use-reserve-when-you-know-the-size-of-the-vector>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Reserve space for 1000 elements.
</span></span></span><span class=line><span class=cl><span class=c1>// v[i] will be an empty object if v[i] has not been assigned a value.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>v</span><span class=p>.</span><span class=n>reserve</span><span class=p>(</span><span class=mi>1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Reserve space for 1000 elements.
</span></span></span><span class=line><span class=cl><span class=c1>// v[i] will be assigned the default value.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>default_value</span> <span class=o>=</span> <span class=s>&#34;default&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>v_strings</span><span class=p>(</span><span class=mi>1000</span><span class=p>,</span> <span class=n>default_value</span><span class=p>);</span>
</span></span></code></pre></div><p>This is due to the way <code>std::vector</code> works. When you push an element into a vector, it checks if the current capacity is enough. If not, it allocates a new memory block, copies the elements, and deallocates the old memory block. This can be very expensive if you are pushing a lot of elements into the vector. By using <code>reserve</code>, you can avoid this overhead. Note that the same can be achieved by specifying the size in the constructor: <code>std::vector&lt;int> v(1000);</code>.</p><p>As you can already tell from the example above, the biggest difference between <code>reserve</code> and calling the constructor to specify the vector size at construction is that <code>reserve</code> does not initialize the slots in the buffer with anything so you shouldn’t reference indexes where you haven’t already put something because they will be uninitialized. On the other hand, when you specify the size in the constructor, each slot is initialized with an empty object or the default value specified in the second argument of the constructor.</p><h3 id=put-pointers-in-stdvector-instead-of-objects>Put pointers in <code>std::vector</code> instead of objects<a hidden class=anchor aria-hidden=true href=#put-pointers-in-stdvector-instead-of-objects>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// modern C++
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>main</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// --------------------------------------------------------------------
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Vector creation and object insertion.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>Foo</span><span class=o>&gt;&gt;</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>v</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>Foo</span><span class=o>&gt;</span><span class=p>(</span><span class=cm>/* constructor args */</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>v</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>Foo</span><span class=o>&gt;</span><span class=p>(</span><span class=cm>/* constructor args */</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// --------------------------------------------------------------------
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// Do something with the objects.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// The objects will be automatically deleted when the vector goes out of scope.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// older C++
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>main</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// --------------------------------------------------------------------
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Vector creation and object insertion.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>Foo</span><span class=o>*&gt;</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>v</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=k>new</span> <span class=n>Foo</span><span class=p>(</span><span class=cm>/* constructor args */</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>v</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=k>new</span> <span class=n>Foo</span><span class=p>(</span><span class=cm>/* constructor args */</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// --------------------------------------------------------------------
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// Do something with the objects.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// --------------------------------------------------------------------
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Typical pipeline to delete the objects when you&#39;re done.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>Foo</span><span class=o>*&gt;::</span><span class=n>iterator</span> <span class=n>it</span> <span class=o>=</span> <span class=n>v</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span> <span class=n>it</span> <span class=o>!=</span> <span class=n>v</span><span class=p>.</span><span class=n>end</span><span class=p>();</span> <span class=o>++</span><span class=n>it</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>delete</span> <span class=o>*</span><span class=n>it</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>v</span><span class=p>.</span><span class=n>clear</span><span class=p>();</span> <span class=c1>// Purge the contents so no one tries to delete them again.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// --------------------------------------------------------------------
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Doing this will reduce copy overhead. This is because an <code>std::vector</code> or any other standard libary container <strong>do not actually stores the object itself</strong>. Instead, it stores a copy of the object. <em>This means that each time you put something in a vector, you aren’t really “putting” it anywhere; you’re copying it somewhere else with its copy constructor or assignment operator (C++ Cookbook, Stephens et. al.)</em>. The same applies to retrieving a value from a vector: <strong>you are copying what is in the vector at that location to your
local variable</strong>. So, if you have a large object, copying it can be expensive. By using pointers, you can avoid this overhead.</p><p>This is because storing pointers require less CPU cycles than storing objects. When you store a pointer in a vector, only the address of the object is stored. This is much faster than copying the object. Also, when you retrieve an object from a vector of pointers, you are just copying the address of the object, not the object itself. This is much faster than copying the object.</p><blockquote><p><strong>If you are using older versions of C++</strong>, just remember that if you add pointers to a standard library container, the container doesn’t delete them when it’s destroyed. Containers destroy only the objects they contain, i.e., the variable holding the addresses of the objects pointed to, but a container doesn’t know that what it’s storing is a pointer or an object, all it knows is that it’s some object of type <code>T</code> (C++ Cookbook, Stephens et. al.).</p></blockquote><h3 id=use-stdlist-instead-of-stdvector-when-you-need-to-insert-elements-arbitrarily>Use <code>std::list</code> instead of <code>std::vector</code> when you need to insert elements arbitrarily.<a hidden class=anchor aria-hidden=true href=#use-stdlist-instead-of-stdvector-when-you-need-to-insert-elements-arbitrarily>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// ... other includes
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&lt;iterator&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>list</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>l</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Say we want to insert 10 between 2 and 3.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>next</span><span class=p>(</span><span class=n>l</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=mi>2</span><span class=p>);</span> <span class=c1>// it points to l[2].
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>l</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>it</span><span class=p>,</span> <span class=mi>10</span><span class=p>);</span> <span class=c1>// l = {1, 2, 10, 3, 4, 5}
</span></span></span></code></pre></div><p>This is because inserting an element in the middle of a vector is expensive. When you insert an element in the middle of a vector, all the elements after the insertion point have to be moved to make space for the new element. This is due to the nature of <code>std::vector</code>: it stores item in a contiguous memory space. This is not the case with <code>std::list</code>. In a list, each element is stored in a separate node, and each node has a pointer to the next node. So, inserting an element in the middle of a list is just a matter of changing the pointers of the nodes.</p><h3 id=copying-a-subset-of-elements-in-an-stdvector>Copying a subset of elements in an <code>std::vector</code><a hidden class=anchor aria-hidden=true href=#copying-a-subset-of-elements-in-an-stdvector>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// ... other includes
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&lt;algorithm&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>v</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>v2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// assign(first, last) copies elements pointed to by first up
</span></span></span><span class=line><span class=cl><span class=c1>// to but not including last, i.e.: [first, last).
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>it</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>find</span><span class=p>(</span><span class=n>v</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>v</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>v2</span><span class=p>.</span><span class=n>assign</span><span class=p>(</span><span class=n>v</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>it</span><span class=p>)</span> <span class=c1>// v2 = {1, 2, 3}
</span></span></span></code></pre></div><p>You can also use a copy constructor but this way is more common.</p><h2 id=tldr-functor>TLDR: Functor<a hidden class=anchor aria-hidden=true href=#tldr-functor>#</a></h2><p>A functor, a.k.a. a function object, is a class that defines/overrides the <code>operator()</code> method. This allows you to create objects that &ldquo;look like&rdquo; functions. Functors are useful when you want to pass a function to another function, or when you want to store a function in a variable.</p><p>Conceptually, it is similar to a Python class with the <code>__call__</code> method defined. Both allow objects to be used as if they were functions.</p><p>I include a minimum-working-example in C++ and Python below.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>CallCounter</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>CallCounter</span><span class=p>()</span> <span class=o>:</span> <span class=n>count</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>operator</span><span class=p>()()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>count</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Called &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>count</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; times&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>count</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>CallCounter</span> <span class=n>counter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>counter</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>counter</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>counter</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>CallCounter</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>count</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__call__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>count</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Called </span><span class=si>{</span><span class=bp>self</span><span class=o>.</span><span class=n>count</span><span class=si>}</span><span class=s2> times&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>counter</span> <span class=o>=</span> <span class=n>CallCounter</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>counter</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>counter</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>counter</span><span class=p>()</span>
</span></span></code></pre></div><h2 id=tldr-predicate>TLDR: Predicate<a hidden class=anchor aria-hidden=true href=#tldr-predicate>#</a></h2><p>It&rsquo;s just a functor that returns a bool. The name <em>&ldquo;predicate&rdquo;</em> is derived from the fact that it does not maintain a state and only returns a boolean value, i.e.: it is <em>pure</em> in some sense (<em>pure</em> ➡ <em>predicate</em>). It is used to test a condition.</p><p>Below are different ways to define a predicate in C++.</p><ol><li>Function Pointer Predicate</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;vector&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;algorithm&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>is_even</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>n</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>numbers</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>find_if</span><span class=p>(</span><span class=n>numbers</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>numbers</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>is_even</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>it</span> <span class=o>!=</span> <span class=n>numbers</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;First even number: &#34;</span> <span class=o>&lt;&lt;</span> <span class=o>*</span><span class=n>it</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ol start=2><li>Functor Predicate</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;vector&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;algorithm&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>IsEven</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=k>operator</span><span class=p>()(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>n</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>numbers</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>find_if</span><span class=p>(</span><span class=n>numbers</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>numbers</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>IsEven</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>it</span> <span class=o>!=</span> <span class=n>numbers</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;First even number: &#34;</span> <span class=o>&lt;&lt;</span> <span class=o>*</span><span class=n>it</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ol start=3><li>Lambda Predicate</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;vector&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;algorithm&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>numbers</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>find_if</span><span class=p>(</span><span class=n>numbers</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>numbers</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=p>[](</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>n</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span><span class=p>;</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>it</span> <span class=o>!=</span> <span class=n>numbers</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;First even number: &#34;</span> <span class=o>&lt;&lt;</span> <span class=o>*</span><span class=n>it</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Some terminologies:</p><ul><li>Unary predicate: A predicate that takes one argument (and returns a bool).</li><li>Binary predicate: A predicate that takes two arguments (and returns a bool).</li></ul><h2 id=whats-actually-happening-in-stdfind_if>What&rsquo;s actually happening in <code>std::find_if</code><a hidden class=anchor aria-hidden=true href=#whats-actually-happening-in-stdfind_if>#</a></h2><p>Let&rsquo;s take look at the function pointer predicate example above. What&rsquo;s actually happening when you pass <code>is_even</code> to <code>std::find_if</code>? When you pass the predicate <code>is_even()</code> to <code>std::find_if</code>, you&rsquo;re actually passing the address of the function, which the algorithm can then call on elements of the container.</p><p>A function pointer is a just variable that stores the address of a function that can be called through it. This allows functions to be passed as arguments to other functions.</p><p>To declare a function pointer, for example, you can simply do the following:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>foo_ptr</span><span class=p>)(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>)</span> <span class=o>=</span> <span class=n>foo</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Now you can call foo through foo_ptr.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=n>foo_ptr</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>);</span>
</span></span></code></pre></div><p>Now, let&rsquo;s take a look at what actually happens in <code>std::find_if</code>. Before that, let&rsquo;s take a look at the signature of <code>std::find_if</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>ExecutionPolicy</span><span class=p>,</span> <span class=k>class</span> <span class=nc>ForwardIt</span><span class=p>,</span> <span class=k>class</span> <span class=nc>UnaryPred</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>ForwardIt</span> <span class=n>find_if</span><span class=p>(</span><span class=n>ExecutionPolicy</span><span class=o>&amp;&amp;</span> <span class=n>policy</span><span class=p>,</span> <span class=n>ForwardIt</span> <span class=n>first</span><span class=p>,</span> <span class=n>ForwardIt</span> <span class=n>last</span><span class=p>,</span> <span class=n>UnaryPred</span> <span class=n>p</span><span class=p>);</span>
</span></span></code></pre></div><p>For now, don&rsquo;t worry about the <code>ExecutionPolicy</code> parameter. The important parameters are <code>ForwardIt first</code>, <code>ForwardIt last</code>, and <code>UnaryPred p</code>. <code>ForwardIt</code> is a type that satisfies the requirements of a forward iterator. <code>UnaryPred</code> is a type that satisfies the requirements of a unary predicate.</p><p>When you pass <code>is_even</code> to <code>std::find_if</code>, you&rsquo;re actually passing the address of the function <code>is_even</code>. The algorithm then calls <code>is_even</code> on each element of the container. Let&rsquo;s take a look at what&rsquo;s happening:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span> <span class=p>;</span> <span class=n>first</span> <span class=o>!=</span> <span class=n>last</span><span class=p>;</span> <span class=o>++</span><span class=n>first</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=p>(</span><span class=o>*</span><span class=n>first</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>first</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>last</span><span class=p>;</span>
</span></span></code></pre></div><p>Here <code>p</code> is called wth <code>*first</code> as argument. In our case, <code>p</code> is a function pointer to <code>is_even</code>, so <code>UnaryPred</code> is <code>bool(*)(int)</code>. So, this translates to:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>is_even</span><span class=p>(</span><span class=o>*</span><span class=n>first</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>first</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span></code></pre></div><h2 id=should-i-preincrement-it-or-postincrement-it-iterators>Should I preincrement (<code>++it</code>) or postincrement (<code>it++</code>) iterators?<a hidden class=anchor aria-hidden=true href=#should-i-preincrement-it-or-postincrement-it-iterators>#</a></h2><p>Preincrement doesn’t create a temporary value to return each time, so it’s more efficient and is the preferred approach. Postincrement (<code>it++</code>) has to create a temporary variable because it returns the value of <code>it</code> before the increment. However, it can’t increment the value after it has returned, so it has to make a copy of the current value, increment the current value, then return the temporary value. Creating these temporary variables adds up after a while, <strong>so if you don’t require postincrement behavior, use preincrement</strong> (C++ Cookbook, Stephens et. al.).</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/c++/>C++</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/lc70/><span class=title>« Prev</span><br><span>LC70: Climbing Stairs (EASY)</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share C++ Tips and Tricks on x" href="https://x.com/intent/tweet/?text=C%2b%2b%20Tips%20and%20Tricks&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fcpp_tips%2f&amp;hashtags=C%2b%2b"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++ Tips and Tricks on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fcpp_tips%2f&amp;title=C%2b%2b%20Tips%20and%20Tricks&amp;summary=C%2b%2b%20Tips%20and%20Tricks&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fcpp_tips%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++ Tips and Tricks on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fcpp_tips%2f&title=C%2b%2b%20Tips%20and%20Tricks"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++ Tips and Tricks on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fcpp_tips%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++ Tips and Tricks on whatsapp" href="https://api.whatsapp.com/send?text=C%2b%2b%20Tips%20and%20Tricks%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fcpp_tips%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++ Tips and Tricks on telegram" href="https://telegram.me/share/url?text=C%2b%2b%20Tips%20and%20Tricks&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fcpp_tips%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++ Tips and Tricks on ycombinator" href="https://news.ycombinator.com/submitlink?t=C%2b%2b%20Tips%20and%20Tricks&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fcpp_tips%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://giscus.app/client.js data-repo=fadli0029/FadeWrites data-repo-id=R_kgDOMO8UQA data-category-id=DIC_kwDOMO8UQM4Cgbk4 data-mapping=url data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=dark data-lang=en data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>fadeWrites</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>